<link rel="stylesheet" href="../assets/style.css">
<div style="padding:18px">
  <h3 style="margin:0 0 12px 0">Network Tools</h3>

  <div class="grid">
    <div class="tool" id="publicIpCard">
      <h4>IP công cộng (Public IP)</h4>
      <div class="row" style="gap:8px; align-items:center">
        <label style="min-width:120px;margin:0">Địa chỉ IP:</label>
        <code id="publicIpOut" style="flex:1">Đang lấy…</code>
      </div>
      <div class="mini">Tự động hiển thị IP public (không cần bấm nút).</div>
    </div>

    <div class="tool" id="sslCheckCard">
      <h4>Check SSL (SSL Labs)</h4>
      <div class="row" style="gap:8px; align-items:flex-end">
        <div style="flex:2">
          <label>Domain</label>
          <input id="sslHost" placeholder="vd: example.com"/>
        </div>
        <div style="flex:1">
          <label>Chế độ</label>
          <select id="sslMode">
            <option value="cache">Dùng cache nếu có</option>
            <option value="fresh">Phân tích mới</option>
          </select>
        </div>
        <button class="btn" id="sslStart">Kiểm tra</button>
        <a class="btn ghost" id="sslOpen" target="_blank" rel="noopener">Mở SSLLabs</a>
      </div>
      <pre class="code" id="sslOut" style="margin-top:8px; max-height:280px"></pre>
      <div class="mini">Nếu API công khai chậm/giới hạn, mở trực tiếp trang SSLLabs.</div>
    </div>

    <div class="tool" id="portScanCard">
      <h4>Scan Port (HTTP/HTTPS)</h4>
      <div class="row" style="gap:8px; align-items:flex-end; flex-wrap:wrap">
        <div style="flex:2">
          <label>Host / IP</label>
          <input id="psHost" placeholder="vd: example.com hoặc 1.2.3.4"/>
        </div>
        <div style="flex:2">
          <label>Cổng</label>
          <input id="psPorts" placeholder="vd: 80,443,8080 hoặc 1-1024"/>
        </div>
        <div style="flex:1">
          <label>Giao thức</label>
          <select id="psScheme">
            <option value="both">HTTP + HTTPS</option>
            <option value="http">HTTP</option>
            <option value="https">HTTPS</option>
          </select>
        </div>
        <div style="flex:1">
          <label>Timeout (ms)</label>
          <input id="psTimeout" type="number" value="3000" min="500" max="15000"/>
        </div>
        <button class="btn" id="psStart">Quét</button>
      </div>
      <pre class="code" id="psOut" style="margin-top:8px; max-height:280px"></pre>
      <div class="mini">Chỉ kiểm tra được dịch vụ HTTP/HTTPS từ trình duyệt (qua proxy). Kết quả phản ánh từ Internet.</div>
    </div>
  </div>
</div>

<script>
// === Public IP (ipify qua allorigins) ===
async function getPublicIp() {
  const url = 'https://api.allorigins.win/raw?url=' + encodeURIComponent('https://api.ipify.org?format=json');
  const out = document.getElementById('publicIpOut');
  out.textContent = 'Đang lấy...';
  try {
    const res = await fetch(url, { cache: 'no-store' });
    const txt = await res.text();
    let ip = '';
    try { ip = JSON.parse(txt).ip; } catch { ip = txt.trim(); }
    out.textContent = ip || '—';
  } catch (e) {
    out.textContent = '⚠️ Lỗi hoặc bị chặn CORS/rate-limit';
  }
}
getPublicIp();

// === SSL Check (SSL Labs qua allorigins) ===
async function sslAnalyze(host, mode='cache'){
  const base = 'https://api.ssllabs.com/api/v3/analyze?publish=off&all=done&ignoreMismatch=on';
  const params = new URLSearchParams({ host });
  if (mode === 'fresh') params.set('startNew','on'); else params.set('fromCache','on');
  const url = base + '&' + params.toString();
  const proxied = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
  const res = await fetch(proxied, { cache: 'no-store' });
  const data = await res.json();
  return data;
}
function formatSsl(data){
  if (!data) return 'Không có dữ liệu.';
  if (data.status && data.status !== 'READY'){
    return `Trạng thái: ${data.status} — ${data.statusMessage || ''}`.trim();
  }
  const lines = [];
  if (data.endpoints && data.endpoints.length){
    for (const ep of data.endpoints){
      const grade = ep.grade || ep.gradeTrustIgnored || '—';
      const ip = ep.ipAddress || '—';
      lines.push(`${ip} → Grade: ${grade}`);
    }
  } else {
    lines.push('Không có endpoint.');
  }
  return lines.join('\\n');
}
document.getElementById('sslStart')?.addEventListener('click', async () => {
  const host = document.getElementById('sslHost').value.trim();
  const mode = document.getElementById('sslMode').value;
  const out = document.getElementById('sslOut');
  const link = document.getElementById('sslOpen');
  if(!host){ out.textContent = 'Nhập domain.'; return; }
  link.href = `https://www.ssllabs.com/ssltest/analyze.html?d=${encodeURIComponent(host)}`;
  out.textContent = 'Đang kiểm tra…';
  try {
    let tries = 0;
    let data = await sslAnalyze(host, mode);
    while (data && data.status && data.status !== 'READY' && tries < 15){
      out.textContent = `Trạng thái: ${data.status}…`;
      await new Promise(r => setTimeout(r, 6000));
      data = await sslAnalyze(host, 'cache');
      tries++;
    }
    out.textContent = formatSsl(data);
  } catch (e){
    out.textContent = '⚠️ Lỗi gọi API hoặc bị chặn CORS.';
  }
});

// === Port Scan (HTTP/HTTPS via allorigins) ===
function parsePorts(input){
  const parts = input.split(',').map(s => s.trim()).filter(Boolean);
  const set = new Set();
  for (const p of parts){
    if (p.includes('-')){
      const [a,b] = p.split('-').map(n=>parseInt(n,10));
      if (Number.isFinite(a) && Number.isFinite(b)){
        for (let i=Math.min(a,b); i<=Math.max(a,b) && i<=65535; i++) set.add(i);
      }
    } else {
      const n = parseInt(p,10);
      if (Number.isFinite(n) && n>0 && n<=65535) set.add(n);
    }
  }
  return Array.from(set).sort((x,y)=>x-y);
}
async function checkPort(host, port, scheme, timeoutMs){
  const target = `${scheme}://${host}:${port}/`;
  const proxied = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(target);
  const ctrl = new AbortController();
  const t = setTimeout(()=> ctrl.abort('timeout'), timeoutMs);
  try {
    const res = await fetch(proxied, { signal: ctrl.signal, cache: 'no-store' });
    clearTimeout(t);
    if (res.ok || res.status === 0){
      return { port, scheme, status: 'có thể mở (HTTP OK/opaque)' };
    }
    return { port, scheme, status: `phản hồi ${res.status}` };
  } catch (e){
    clearTimeout(t);
    return { port, scheme, status: (e && e.name === 'AbortError') ? 'timeout' : 'không kết nối' };
  }
}
document.getElementById('psStart')?.addEventListener('click', async ()=>{
  const host = document.getElementById('psHost').value.trim();
  const ports = parsePorts(document.getElementById('psPorts').value.trim());
  const schemeSel = document.getElementById('psScheme').value;
  const timeoutMs = parseInt(document.getElementById('psTimeout').value, 10) || 3000;
  const out = document.getElementById('psOut');
  if (!host || ports.length===0){ out.textContent = 'Nhập host và danh sách cổng hợp lệ.'; return; }
  out.textContent = `Đang quét ${host} trên ${ports.length} cổng...\\n`;
  const schemes = schemeSel==='both' ? ['http','https'] : [schemeSel];
  const tasks = [];
  for (const port of ports){
    for (const sch of schemes){
      tasks.push(checkPort(host, port, sch, timeoutMs));
    }
  }
  const CONC = 6;
  const results = [];
  let idx = 0;
  async function runNext(){
    if (idx >= tasks.length) return;
    const i = idx++;
    const r = await tasks[i];
    results.push(r);
    out.textContent = results.map(x=>`${x.scheme.toUpperCase()} ${x.port}: ${x.status}`).join('\\n');
    await runNext();
  }
  await Promise.all(new Array(Math.min(CONC, tasks.length)).fill(0).map(()=>runNext()));
  out.textContent += `\\nHoàn tất.`;
});
</script>