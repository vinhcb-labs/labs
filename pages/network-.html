<link rel="stylesheet" href="./style.css">
<style>
/* Fallback styles (in case global CSS fails to apply) */
.tool input, .tool textarea, .tool select {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--surface);
  background: var(--surface);
  color: var(--text);
  outline: none;
}
.tool input::placeholder, .tool textarea::placeholder { color: var(--subtle); }
.btn { display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 10px; border: 0; cursor: pointer; background: var(--primary); color: #fff; text-decoration: none; }
.btn.ghost { background: transparent; color: var(--text); border: 1px dashed var(--subtle); }
.row { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; }
.tool { background: var(--muted); padding: 12px; border-radius: 12px; border: 1px solid var(--surface); }
</style>

<div style="padding:18px">
  <h3 style="margin:0 0 12px 0">Network Tools</h3>

  <div class="grid">
    <!-- Compact one-line IP display -->
    <div class="tool" id="publicIpCard">
      <h4 style="margin:0">IP PUBLIC: <code id="publicIpCompact">Đang lấy…</code></h4>
    </div>

    <div class="tool" id="sslCheckCard">
      <h4>Check SSL</h4>
      <div class="row" style="gap:8px; align-items:flex-end">
        <div style="flex:2">
          <label>Domain</label>
          <input id="sslHost" placeholder="vd: example.com"/>
        </div>
        <div style="flex:1">
          <label>Chế độ</label>
          <select id="sslMode">
            <option value="cache">Dùng cache nếu có</option>
            <option value="fresh">Phân tích mới</option>
          </select>
        </div>
        <button class="btn" id="sslStart">Kiểm tra</button>
        <a class="btn ghost" id="sslOpen" target="_blank" rel="noopener">Mở SSLLabs</a>
      </div>
      <pre class="code" id="sslOut" style="margin-top:8px; max-height:280px"></pre>
      <div class="mini">Nếu API công khai chậm/giới hạn, mở trực tiếp trang SSLLabs.</div>
    </div>

    <div class="tool" id="portScanCard">
      <h4>Scan Port (HTTP/HTTPS)</h4>
      <div class="row" style="gap:8px; align-items:flex-end; flex-wrap:wrap">
        <div style="flex:2">
          <label>Host / IP</label>
          <input id="psHost" placeholder="vd: example.com hoặc 1.2.3.4"/>
        </div>
        <div style="flex:2">
          <label>Cổng</label>
          <input id="psPorts" placeholder="vd: 80,443,8080 hoặc 1-1024"/>
        </div>
        <div style="flex:1">
          <label>Giao thức</label>
          <select id="psScheme">
            <option value="both">HTTP + HTTPS</option>
            <option value="http">HTTP</option>
            <option value="https">HTTPS</option>
          </select>
        </div>
        <div style="flex:1">
          <label>Timeout (ms)</label>
          <input id="psTimeout" type="number" value="3000" min="500" max="15000"/>
        </div>
        <button class="btn" id="psStart">Quét</button>
      </div>
      <pre class="code" id="psOut" style="margin-top:8px; max-height:280px"></pre>
      <div class="mini">Chỉ kiểm tra được dịch vụ HTTP/HTTPS từ trình duyệt (qua proxy). Kết quả phản ánh từ Internet.</div>
    </div>
  </div>
</div>

<script>
// === Public IP (WAN egress) with v4/v6 & multi-source fallback ===
const ipv4re = /^(?:\d{1,3}\.){3}\d{1,3}$/;
const ipv6re = /^[0-9a-f:]+$/i;

async function fetchJSON(url, timeout=6000){
  const ctrl = new AbortController(); const t = setTimeout(()=>ctrl.abort('timeout'), timeout);
  try { const r = await fetch(url, { cache:'no-store', signal: ctrl.signal }); clearTimeout(t); return await r.json(); }
  catch(e){ clearTimeout(t); throw e; }
}
async function fetchTEXT(url, timeout=6000){
  const ctrl = new AbortController(); const t = setTimeout(()=>ctrl.abort('timeout'), timeout);
  try { const r = await fetch(url, { cache:'no-store', signal: ctrl.signal }); clearTimeout(t); return await r.text(); }
  catch(e){ clearTimeout(t); throw e; }
}
async function tryAll(tasks){
  for (const t of tasks){
    try { const v = await t(); if (v) return v; } catch {}
  }
  return '';
}

async function getIPv4(){
  return await tryAll([
    async()=>{ const j = await fetchJSON('https://api4.ipify.org?format=json'); return ipv4re.test(j.ip)? j.ip : ''; },
    async()=>{ const j = await fetchJSON('https://api.allorigins.win/raw?url=' + encodeURIComponent('https://api4.ipify.org?format=json')); return ipv4re.test(j.ip)? j.ip : ''; },
    async()=>{ const j = await fetchJSON('https://api.myip.com'); return ipv4re.test(j.ip)? j.ip : ''; },
    async()=>{ const j = await fetchJSON('https://api.allorigins.win/raw?url=' + encodeURIComponent('https://api.myip.com')); return ipv4re.test(j.ip)? j.ip : ''; },
    async()=>{ const t = await fetchTEXT('https://ifconfig.me/ip'); const v=t.trim(); return ipv4re.test(v)? v : ''; },
    async()=>{ const t = await fetchTEXT('https://api.allorigins.win/raw?url=' + encodeURIComponent('https://ifconfig.me/ip')); const v=t.trim(); return ipv4re.test(v)? v : ''; }
  ]);
}

async function getIPv6(){
  return await tryAll([
    async()=>{ const j = await fetchJSON('https://api6.ipify.org?format=json'); return ipv6re.test(j.ip)? j.ip : ''; },
    async()=>{ const j = await fetchJSON('https://api.allorigins.win/raw?url=' + encodeURIComponent('https://api6.ipify.org?format=json')); return ipv6re.test(j.ip)? j.ip : ''; },
    async()=>{ const t = await fetchTEXT('https://ipv6.icanhazip.com/'); const v=t.trim(); return ipv6re.test(v)? v : ''; },
    async()=>{ const t = await fetchTEXT('https://api.allorigins.win/raw?url=' + encodeURIComponent('https://ipv6.icanhazip.com/')); const v=t.trim(); return ipv6re.test(v)? v : ''; }
  ]);
}

async function initPublicIp(){
  const el = document.getElementById('publicIpCompact');
  if (el) el.textContent = 'Đang lấy…';

  try {
    const [v4, v6] = await Promise.all([getIPv4(), getIPv6()]);
    const display = v4 || v6 || '—';
    if (el) el.textContent = display;
  } catch {
    if (el) el.textContent = '⚠️ Lỗi lấy IP';
  }
}
initPublicIp();

// === SSL Check (SSL Labs qua allorigins) ===
async function sslAnalyze(host, mode='cache'){
  const base = 'https://api.ssllabs.com/api/v3/analyze?publish=off&all=done&ignoreMismatch=on';
  const params = new URLSearchParams({ host });
  if (mode === 'fresh') params.set('startNew','on'); else params.set('fromCache','on');
  const url = base + '&' + params.toString();
  const proxied = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url);
  const res = await fetch(proxied, { cache: 'no-store' });
  const data = await res.json();
  return data;
}
function formatSsl(data){
  if (!data) return 'Không có dữ liệu.';
  if (data.status && data.status !== 'READY'){
    return `Trạng thái: ${data.status} — ${data.statusMessage || ''}`.trim();
  }
  const lines = [];
  if (data.endpoints && data.endpoints.length){
    for (const ep of data.endpoints){
      const grade = ep.grade || ep.gradeTrustIgnored || '—';
      const ip = ep.ipAddress || '—';
      lines.push(`${ip} → Grade: ${grade}`);
    }
  } else {
    lines.push('Không có endpoint.');
  }
  return lines.join('\n');
}
document.getElementById('sslStart')?.addEventListener('click', async () => {
  const host = document.getElementById('sslHost').value.trim();
  const mode = document.getElementById('sslMode').value;
  const out = document.getElementById('sslOut');
  const link = document.getElementById('sslOpen');
  if(!host){ out.textContent = 'Nhập domain.'; return; }
  link.href = `https://www.ssllabs.com/ssltest/analyze.html?d=${encodeURIComponent(host)}`;
  out.textContent = 'Đang kiểm tra…';
  try {
    let tries = 0;
    let data = await sslAnalyze(host, mode);
    while (data && data.status && data.status !== 'READY' && tries < 15){
      out.textContent = `Trạng thái: ${data.status}…`;
      await new Promise(r => setTimeout(r, 6000));
      data = await sslAnalyze(host, 'cache');
      tries++;
    }
    out.textContent = formatSsl(data);
  } catch (e){
    out.textContent = '⚠️ Lỗi gọi API hoặc bị chặn CORS.';
  }
});

// === Port Scan (HTTP/HTTPS via allorigins) ===
function parsePorts(input){
  const parts = input.split(',').map(s => s.trim()).filter(Boolean);
  const set = new Set();
  for (const p of parts){
    if (p.includes('-')){
      const [a,b] = p.split('-').map(n=>parseInt(n,10));
      if (Number.isFinite(a) && Number.isFinite(b)){
        for (let i=Math.min(a,b); i<=Math.max(a,b) && i<=65535; i++) set.add(i);
      }
    } else {
      const n = parseInt(p,10);
      if (Number.isFinite(n) && n>0 && n<=65535) set.add(n);
    }
  }
  return Array.from(set).sort((x,y)=>x-y);
}
async function checkPort(host, port, scheme, timeoutMs){
  const target = `${scheme}://${host}:${port}/`;
  const proxied = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(target);
  const ctrl = new AbortController();
  const t = setTimeout(()=> ctrl.abort('timeout'), timeoutMs);
  try {
    const res = await fetch(proxied, { signal: ctrl.signal, cache: 'no-store' });
    clearTimeout(t);
    if (res.ok || res.status === 0){
      return { port, scheme, status: 'có thể mở (HTTP OK/opaque)' };
    }
    return { port, scheme, status: `phản hồi ${res.status}` };
  } catch (e){
    clearTimeout(t);
    return { port, scheme, status: (e && e.name === 'AbortError') ? 'timeout' : 'không kết nối' };
  }
}
document.getElementById('psStart')?.addEventListener('click', async ()=>{
  const host = document.getElementById('psHost').value.trim();
  const ports = parsePorts(document.getElementById('psPorts').value.trim());
  const schemeSel = document.getElementById('psScheme').value;
  const timeoutMs = parseInt(document.getElementById('psTimeout').value, 10) || 3000;
  const out = document.getElementById('psOut');
  if (!host || ports.length===0){ out.textContent = 'Nhập host và danh sách cổng hợp lệ.'; return; }
  out.textContent = `Đang quét ${host} trên ${ports.length} cổng...\n`;
  const schemes = schemeSel==='both' ? ['http','https'] : [schemeSel];
  const tasks = [];
  for (const port of ports){
    for (const sch of schemes){
      tasks.push(checkPort(host, port, sch, timeoutMs));
    }
  }
  const CONC = 6;
  const results = [];
  let idx = 0;
  async function runNext(){
    if (idx >= tasks.length) return;
    const i = idx++;
    const r = await tasks[i];
    results.push(r);
    out.textContent = results.map(x=>`${x.scheme.toUpperCase()} ${x.port}: ${x.status}`).join('\n');
    await runNext();
  }
  await Promise.all(new Array(Math.min(CONC, tasks.length)).fill(0).map(()=>runNext()));
  out.textContent += `\nHoàn tất.`;
});
</script>
